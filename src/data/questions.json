[
  {
    "slug": "G:\\projects\\effective-swe-concepts\\content\\AWS\\s3-versioning",
    "title": "Enabling Versioning in Amazon S3",
    "tags": [
      "aws",
      "s3",
      "versioning",
      "durability"
    ],
    "difficulty": "medium",
    "date": "2025-06-25T00:00:00.000Z",
    "content": "\r\n### 📌 Question  \r\nHow do you enable and use versioning in an S3 bucket?\r\n\r\n---\r\n\r\n### 🧠 Answer\r\n\r\nVersioning in S3 allows you to preserve, retrieve, and restore **every version of every object** stored in a bucket.\r\n\r\nThis helps:\r\n- Protect against accidental overwrites or deletes\r\n- Implement backup & restore strategies\r\n- Support eventual archival (via Glacier)\r\n\r\n---\r\n\r\n### ⚙️ Enabling Versioning (CLI)\r\n\r\n```bash\r\naws s3api put-bucket-versioning \\\r\n  --bucket my-bucket-name \\\r\n  --versioning-configuration Status=Enabled\r\n```\r\n\r\n```terraform\r\nresource \"aws_s3_bucket\" \"main\" {\r\n  bucket = \"my-bucket-name\"\r\n}\r\n\r\nresource \"aws_s3_bucket_versioning\" \"versioning\" {\r\n  bucket = aws_s3_bucket.main.id\r\n\r\n  versioning_configuration {\r\n    status = \"Enabled\"\r\n  }\r\n}\r\n```",
    "topic": "AWS"
  },
  {
    "slug": "G:\\projects\\effective-swe-concepts\\content\\Java\\Does an Abstract Class Have a Constructor",
    "title": "Does Abstract class have constructor?",
    "tags": [
      "java",
      "java-basics"
    ],
    "difficulty": "easy",
    "date": "2025-06-22T00:00:00.000Z",
    "content": "\r\n## Does an Abstract Class Have a Constructor?\r\n\r\nYes — this is a common interview question, and the answer is:\r\n\r\n> ✅ **Yes, abstract classes in Java do have constructors.**  \r\nYou can define one explicitly, or Java will provide a default constructor if you don't.\r\n\r\n### Why does an abstract class need a constructor?\r\n\r\nEven though you **cannot instantiate** an abstract class directly, its constructor is still called **when a subclass is instantiated**. The constructor helps to **initialize data members** defined in the abstract class.\r\n\r\n### Important Concepts:\r\n\r\n- Constructors are used to initialize instance variables.\r\n- An abstract class **can have instance variables** (just like any class).\r\n- When a subclass extends an abstract class and is instantiated, the **abstract class constructor is executed first** via an implicit or explicit `super()` call.\r\n\r\n### Example:\r\n\r\n```java\r\nabstract class Vehicle {\r\n    String type;\r\n\r\n    Vehicle(String type) {\r\n        this.type = type;\r\n        System.out.println(\"Vehicle constructor called: \" + type);\r\n    }\r\n}\r\n\r\nclass Car extends Vehicle {\r\n    Car() {\r\n        super(\"Car\");\r\n        System.out.println(\"Car constructor called\");\r\n    }\r\n}\r\n\r\npublic class Main {\r\n    public static void main(String[] args) {\r\n        Car c = new Car();\r\n    }\r\n}\r\n```\r\n\r\n### Output:\r\n\r\n```\r\nVehicle constructor called: Car\r\nCar constructor called\r\n```\r\n\r\nAs shown above:\r\n- The abstract class `Vehicle` has a constructor.\r\n- When `Car` is instantiated, `Vehicle`'s constructor is called first using `super(\"Car\")`.\r\n\r\nThis demonstrates that **abstract class constructors participate in the object initialization chain**, just like constructors in concrete superclasses.\r\n\r\n\r\n",
    "topic": "Java"
  },
  {
    "slug": "G:\\projects\\effective-swe-concepts\\content\\Java\\What are the 4 pillars of OOPS",
    "title": "What are the 4 pillars of OOPS?",
    "tags": [
      "java",
      "OOP",
      "java-basics"
    ],
    "difficulty": "easy",
    "date": "2025-06-22T00:00:00.000Z",
    "content": "\r\n## Answer: 4 Pillars of OOP (Object-Oriented Programming)\r\n\r\nThe four fundamental pillars of OOP are:\r\n\r\n1. **Abstraction**  \r\n2. **Encapsulation**  \r\n3. **Inheritance**  \r\n4. **Polymorphism**\r\n\r\n---\r\n\r\n### 1. Abstraction\r\n\r\n**Definition**: Abstraction is the process of hiding internal implementation details and showing only the functionality to the user.\r\n\r\n**Real-world examples**:\r\n- **TV Remote**: To turn on the TV, you press the power button — you don’t need to know how the internal circuits work or how infrared signals are transmitted.\r\n- **Car Gear**: You know what happens when you change gears, but the underlying mechanism is hidden from you. That technical detail is abstracted.\r\n\r\n**In Java**, abstraction can be achieved in two ways:\r\n- Using **abstract classes**\r\n- Using **interfaces**\r\n\r\n```java\r\n// Abstract class example\r\nabstract class Animal {\r\n    abstract void makeSound();\r\n}\r\n\r\nclass Dog extends Animal {\r\n    void makeSound() {\r\n        System.out.println(\"Bark\");\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### 2. Encapsulation\r\n\r\n**Definition**: Encapsulation is the process of binding data (variables) and methods that operate on the data into a single unit — typically a class. It is also used to restrict access to internal details using access modifiers (`private`, `public`, `protected`).\r\n\r\nEncapsulation supports **data hiding** and helps in achieving **abstraction**.\r\n\r\n**Example**:  \r\nA Java Bean where all data members are private and are accessed via public getters/setters.\r\n\r\n```java\r\npublic class Person {\r\n    private String name;\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### 3. Inheritance\r\n\r\n**Definition**: Inheritance allows one class (child/subclass) to inherit properties and methods from another class (parent/superclass). This promotes **code reusability** and establishes a **parent-child relationship** between classes.\r\n\r\n> Java supports single inheritance through classes and multiple inheritance through interfaces.\r\n\r\n**Example**:\r\n```java\r\nclass Animal {\r\n    void eat() {\r\n        System.out.println(\"This animal eats food\");\r\n    }\r\n}\r\n\r\nclass Dog extends Animal {\r\n    void bark() {\r\n        System.out.println(\"The dog barks\");\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### 4. Polymorphism\r\n\r\n**Definition**: \"Poly\" means many, and \"morph\" means forms. Polymorphism allows objects or methods to take multiple forms.\r\n\r\nThere are **two types of polymorphism**:\r\n\r\n#### a) Compile-time Polymorphism (Method Overloading)\r\nOccurs when multiple methods have the same name but different parameters in the same class. The method to call is decided at **compile-time**.\r\n\r\n```java\r\nclass MathUtils {\r\n    int add(int a, int b) {\r\n        return a + b;\r\n    }\r\n\r\n    double add(double a, double b) {\r\n        return a + b;\r\n    }\r\n}\r\n```\r\n\r\n#### b) Run-time Polymorphism (Method Overriding)\r\nOccurs when a subclass provides a specific implementation of a method already defined in its superclass. The method to call is determined at **runtime**.\r\n\r\n```java\r\nclass Animal {\r\n    void sound() {\r\n        System.out.println(\"Animal makes sound\");\r\n    }\r\n}\r\n\r\nclass Cat extends Animal {\r\n    void sound() {\r\n        System.out.println(\"Cat meows\");\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Summary Table\r\n\r\n| Pillar        | Key Concept                            | Java Support                         |\r\n|---------------|----------------------------------------|--------------------------------------|\r\n| Abstraction   | Hide internal details, show only needed| Abstract classes, Interfaces         |\r\n| Encapsulation | Bind data & methods, restrict access   | Classes, Access Modifiers            |\r\n| Inheritance   | Reuse code via parent-child classes    | `extends`, Interfaces (`implements`) |\r\n| Polymorphism  | One name, many forms                   | Overloading & Overriding             |\r\n\r\n",
    "topic": "Java"
  },
  {
    "slug": "G:\\projects\\effective-swe-concepts\\content\\Java\\What is an abstract class",
    "title": "What is an abstract class?",
    "tags": [
      "java",
      "java-basics"
    ],
    "difficulty": "easy",
    "date": "2025-06-22T00:00:00.000Z",
    "content": "\r\n## What is an Abstract Class?\r\n\r\nAn **abstract class** is a class that is declared using the `abstract` keyword. It can contain:\r\n\r\n- **Abstract methods** (methods without a body)\r\n- **Concrete methods** (methods with a body)\r\n\r\n### Key Characteristics:\r\n\r\n- An abstract class **cannot be instantiated** — you cannot create objects of it directly.\r\n- The purpose of an abstract class is to be **extended** by other classes.\r\n- The **first concrete (non-abstract) subclass** that extends an abstract class **must implement** all its abstract methods.\r\n\r\n### Example in Java:\r\n\r\n```java\r\nabstract class Animal {\r\n    abstract void makeSound();  // abstract method\r\n\r\n    void breathe() {\r\n        System.out.println(\"Breathing...\");\r\n    }\r\n}\r\n\r\nclass Dog extends Animal {\r\n    void makeSound() {\r\n        System.out.println(\"Bark\");\r\n    }\r\n}\r\n```\r\n\r\nIn the above example:\r\n- `Animal` is an abstract class with one abstract method (`makeSound`) and one concrete method (`breathe`).\r\n- `Dog` is a concrete class that provides an implementation for `makeSound`.\r\n\r\nYou **must** override all abstract methods in the first non-abstract subclass, or the subclass itself must be declared `abstract`.\r\n\r\n\r\n",
    "topic": "Java"
  }
]